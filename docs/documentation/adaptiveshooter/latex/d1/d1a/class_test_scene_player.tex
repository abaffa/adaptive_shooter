\hypertarget{class_test_scene_player}{
\section{TestScenePlayer Class Reference}
\label{d1/d1a/class_test_scene_player}\index{TestScenePlayer@{TestScenePlayer}}
}


{\ttfamily \#include $<$TestScenePlayer.h$>$}



Inheritance diagram for TestScenePlayer:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=170pt]{d9/da9/class_test_scene_player__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for TestScenePlayer:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=217pt]{df/db9/class_test_scene_player__coll__graph}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_test_scene_player_1_1_enemy_description}{EnemyDescription}
\item 
struct \hyperlink{struct_test_scene_player_1_1_wave}{Wave}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4}{EnemyDescriptionData} \{ \par
\hyperlink{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a4f83bf61616ba0f29c9644f621fcc847}{EDD\_\-SPRITE\_\-RESOURCE} =  1, 
\hyperlink{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4ad24ebd6ba2dd453c1503bb5ce391c6a7}{EDD\_\-START\_\-X}, 
\hyperlink{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4aaa6042868eb718491f25d62285bbc802}{EDD\_\-START\_\-Y}, 
\hyperlink{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a3ece89b82fd905bdb4441d416ba05cde}{EDD\_\-SPEED\_\-X}, 
\par
\hyperlink{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a59205b701a679a069c5f4492dfa0fe2f}{EDD\_\-SPEED\_\-Y}, 
\hyperlink{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a25fd718425e72f6131d685f2b2eef6ec}{EDD\_\-BEHAVIOR}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_test_scene_player_a57de11c1a82f2680f88c183f52bff381}{TestScenePlayer} ()
\item 
virtual \hyperlink{class_test_scene_player_ade2a77d3f2edd8d037b2cba2796500c9}{$\sim$TestScenePlayer} ()
\item 
virtual void \hyperlink{class_test_scene_player_a17140146d2a39f10eb3aed81c067ec24}{draw} ()
\item 
virtual void \hyperlink{class_test_scene_player_a8285c9f16119d8423a0ed4858327097c}{update} ()
\item 
void \hyperlink{class_test_scene_player_add7c45987005966e06ce65159f4cd343}{addPlayerShot} (\hyperlink{class_shot}{Shot} $\ast$newShot)
\item 
void \hyperlink{class_test_scene_player_af1b8508a360ec7d4adc231a6f841c897}{addEnemyShot} (\hyperlink{class_shot}{Shot} $\ast$newShot)
\end{DoxyCompactItemize}


\subsection{Member Enumeration Documentation}
\hypertarget{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4}{
\index{TestScenePlayer@{TestScenePlayer}!EnemyDescriptionData@{EnemyDescriptionData}}
\index{EnemyDescriptionData@{EnemyDescriptionData}!TestScenePlayer@{TestScenePlayer}}
\subsubsection[{EnemyDescriptionData}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf TestScenePlayer::EnemyDescriptionData}}}
\label{d1/d1a/class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4}
\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{EDD\_\-SPRITE\_\-RESOURCE@{EDD\_\-SPRITE\_\-RESOURCE}!TestScenePlayer@{TestScenePlayer}}\index{TestScenePlayer@{TestScenePlayer}!EDD\_\-SPRITE\_\-RESOURCE@{EDD\_\-SPRITE\_\-RESOURCE}}\item[{\em 
\hypertarget{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a4f83bf61616ba0f29c9644f621fcc847}{
EDD\_\-SPRITE\_\-RESOURCE}
\label{d1/d1a/class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a4f83bf61616ba0f29c9644f621fcc847}
}]\index{EDD\_\-START\_\-X@{EDD\_\-START\_\-X}!TestScenePlayer@{TestScenePlayer}}\index{TestScenePlayer@{TestScenePlayer}!EDD\_\-START\_\-X@{EDD\_\-START\_\-X}}\item[{\em 
\hypertarget{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4ad24ebd6ba2dd453c1503bb5ce391c6a7}{
EDD\_\-START\_\-X}
\label{d1/d1a/class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4ad24ebd6ba2dd453c1503bb5ce391c6a7}
}]\index{EDD\_\-START\_\-Y@{EDD\_\-START\_\-Y}!TestScenePlayer@{TestScenePlayer}}\index{TestScenePlayer@{TestScenePlayer}!EDD\_\-START\_\-Y@{EDD\_\-START\_\-Y}}\item[{\em 
\hypertarget{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4aaa6042868eb718491f25d62285bbc802}{
EDD\_\-START\_\-Y}
\label{d1/d1a/class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4aaa6042868eb718491f25d62285bbc802}
}]\index{EDD\_\-SPEED\_\-X@{EDD\_\-SPEED\_\-X}!TestScenePlayer@{TestScenePlayer}}\index{TestScenePlayer@{TestScenePlayer}!EDD\_\-SPEED\_\-X@{EDD\_\-SPEED\_\-X}}\item[{\em 
\hypertarget{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a3ece89b82fd905bdb4441d416ba05cde}{
EDD\_\-SPEED\_\-X}
\label{d1/d1a/class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a3ece89b82fd905bdb4441d416ba05cde}
}]\index{EDD\_\-SPEED\_\-Y@{EDD\_\-SPEED\_\-Y}!TestScenePlayer@{TestScenePlayer}}\index{TestScenePlayer@{TestScenePlayer}!EDD\_\-SPEED\_\-Y@{EDD\_\-SPEED\_\-Y}}\item[{\em 
\hypertarget{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a59205b701a679a069c5f4492dfa0fe2f}{
EDD\_\-SPEED\_\-Y}
\label{d1/d1a/class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a59205b701a679a069c5f4492dfa0fe2f}
}]\index{EDD\_\-BEHAVIOR@{EDD\_\-BEHAVIOR}!TestScenePlayer@{TestScenePlayer}}\index{TestScenePlayer@{TestScenePlayer}!EDD\_\-BEHAVIOR@{EDD\_\-BEHAVIOR}}\item[{\em 
\hypertarget{class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a25fd718425e72f6131d685f2b2eef6ec}{
EDD\_\-BEHAVIOR}
\label{d1/d1a/class_test_scene_player_a0072e80704a4a0bf0c0e0d165d2c54e4a25fd718425e72f6131d685f2b2eef6ec}
}]\end{description}
\end{Desc}


\begin{DoxyCode}
        {
                EDD_SPRITE_RESOURCE = 1,
                EDD_START_X,
                EDD_START_Y,
                EDD_SPEED_X,
                EDD_SPEED_Y,
                EDD_BEHAVIOR
        };
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_test_scene_player_a57de11c1a82f2680f88c183f52bff381}{
\index{TestScenePlayer@{TestScenePlayer}!TestScenePlayer@{TestScenePlayer}}
\index{TestScenePlayer@{TestScenePlayer}!TestScenePlayer@{TestScenePlayer}}
\subsubsection[{TestScenePlayer}]{\setlength{\rightskip}{0pt plus 5cm}TestScenePlayer::TestScenePlayer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{d1/d1a/class_test_scene_player_a57de11c1a82f2680f88c183f52bff381}

\begin{DoxyCode}
                                 : _shotsWave( 0 ), _shotsWaveOnTarget( 0 ), _sho
      tsTotal( 0 ),
        _shotsTotalOnTarget( 0 ), _livesStartWave( 0 ), _livesEndWave( 0 ), _enem
      iesWave( 0 ), _enemiesWaveWasted( 0 ),
        _enemiesTotal( 0 ), _enemiesTotalWasted( 0 ), _keyDelayTime ( 1000.0f ), 
      _timer( 0.0f ), _canPressKey( true ), _waveNumber( 0 ), _waveOn(false)
{
        CL_GraphicContext gc = GameManager::getInstance()->getWindow()->get_gc();
      
        _font = new CL_Font( gc, "Tahoma", 16 );

#ifdef _DEBUG
        loadScene( "../../../../src/Scripts/demoscene.lua" );
#else
        loadScene( "./Scripts/demoscene.lua" );
#endif
}
\end{DoxyCode}


Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{d1/d1a/class_test_scene_player_a57de11c1a82f2680f88c183f52bff381_cgraph}
\end{center}
\end{figure}


\hypertarget{class_test_scene_player_ade2a77d3f2edd8d037b2cba2796500c9}{
\index{TestScenePlayer@{TestScenePlayer}!$\sim$TestScenePlayer@{$\sim$TestScenePlayer}}
\index{$\sim$TestScenePlayer@{$\sim$TestScenePlayer}!TestScenePlayer@{TestScenePlayer}}
\subsubsection[{$\sim$TestScenePlayer}]{\setlength{\rightskip}{0pt plus 5cm}TestScenePlayer::$\sim$TestScenePlayer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{d1/d1a/class_test_scene_player_ade2a77d3f2edd8d037b2cba2796500c9}

\begin{DoxyCode}
{
        delete _font;
}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{class_test_scene_player_af1b8508a360ec7d4adc231a6f841c897}{
\index{TestScenePlayer@{TestScenePlayer}!addEnemyShot@{addEnemyShot}}
\index{addEnemyShot@{addEnemyShot}!TestScenePlayer@{TestScenePlayer}}
\subsubsection[{addEnemyShot}]{\setlength{\rightskip}{0pt plus 5cm}void TestScenePlayer::addEnemyShot (
\begin{DoxyParamCaption}
\item[{{\bf Shot} $\ast$}]{newShot}
\end{DoxyParamCaption}
)}}
\label{d1/d1a/class_test_scene_player_af1b8508a360ec7d4adc231a6f841c897}
Adds an enemy shot to the \hyperlink{class_scene}{Scene} entities and enemies' shots control list


\begin{DoxyParams}{Parameters}
{\em newShot} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}

\begin{DoxyCode}
{
        // For drawing and updating
        insertEntity( newShot );

        // For collision checking
        _enemyShots.push_back( newShot );
}
\end{DoxyCode}


Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=380pt]{d1/d1a/class_test_scene_player_af1b8508a360ec7d4adc231a6f841c897_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{d1/d1a/class_test_scene_player_af1b8508a360ec7d4adc231a6f841c897_icgraph}
\end{center}
\end{figure}


\hypertarget{class_test_scene_player_add7c45987005966e06ce65159f4cd343}{
\index{TestScenePlayer@{TestScenePlayer}!addPlayerShot@{addPlayerShot}}
\index{addPlayerShot@{addPlayerShot}!TestScenePlayer@{TestScenePlayer}}
\subsubsection[{addPlayerShot}]{\setlength{\rightskip}{0pt plus 5cm}void TestScenePlayer::addPlayerShot (
\begin{DoxyParamCaption}
\item[{{\bf Shot} $\ast$}]{newShot}
\end{DoxyParamCaption}
)}}
\label{d1/d1a/class_test_scene_player_add7c45987005966e06ce65159f4cd343}
Adds a player shot to the \hyperlink{class_scene}{Scene} entities and player's shots control list


\begin{DoxyParams}{Parameters}
{\em newShot} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}

\begin{DoxyCode}
{
        // For drawing and updating
        insertEntity( newShot );

        // For collision checking
        _playerShots.push_back( newShot );

        _shotsTotal++;
        _shotsWave++;
}
\end{DoxyCode}


Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=378pt]{d1/d1a/class_test_scene_player_add7c45987005966e06ce65159f4cd343_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{d1/d1a/class_test_scene_player_add7c45987005966e06ce65159f4cd343_icgraph}
\end{center}
\end{figure}


\hypertarget{class_test_scene_player_a17140146d2a39f10eb3aed81c067ec24}{
\index{TestScenePlayer@{TestScenePlayer}!draw@{draw}}
\index{draw@{draw}!TestScenePlayer@{TestScenePlayer}}
\subsubsection[{draw}]{\setlength{\rightskip}{0pt plus 5cm}void TestScenePlayer::draw (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{d1/d1a/class_test_scene_player_a17140146d2a39f10eb3aed81c067ec24}


Reimplemented from \hyperlink{class_scene_ac0e3d2c98ba6063a086467fb2c19142f}{Scene}.


\begin{DoxyCode}
{
        CL_GraphicContext gc = GameManager::getInstance()->getWindow()->get_gc();
      

        /*CL_Draw::line(gc, 0, 110, 640, 110, CL_Colorf::yellow);
        _font->draw_text(gc, 100, 100, "Hello World!", CL_Colorf::lightseagreen);
      */

        Player* playerOne = GameManager::getInstance()->getPlayer(0);
        playerOne->draw();

        // Calls parent draw implementation for drawing entities
        Scene::draw();

        _font->draw_text( gc, 10, 440, cl_format( "Lives: %1", playerOne->
      getLives() ), CL_Colorf::whitesmoke );

        _font->draw_text( gc, 500, 440, cl_format( "Score: %1", playerOne->
      getScore() ), CL_Colorf::whitesmoke );

#if _DEBUG
        std::ostringstream playerText;
        playerText.precision( 4 );

        playerText << "Player " << (playerOne->getPlayerNumber() + 1) << std::end
      l;
        playerText << "SpeedX = " << (playerOne->getSpeed().x) << " SpeedY = " <<
       (playerOne->getSpeed().y) << std::endl;
        playerText << "Shot timer: " << (playerOne->getCurrentWeapon()->getDelay(
      ) - playerOne->getCurrentWeapon()->getTimer()) << std::endl;
        playerText << "Model = " << playerOne->getPlayerModel()->getName() << std
      ::endl;
        playerText << "Firing accuracy = " << playerOne->getPlayerModel()->getTra
      itValue( PlayerModelImpl::ACCURACY ) << std::endl;
        playerText << "Lives variation = " << playerOne->getPlayerModel()->getTra
      itValue( PlayerModelImpl::LIVES_VARIATION ) << std::endl;
        playerText << "Enemies wasted wave = " << playerOne->getPlayerModel()->ge
      tTraitValue( PlayerModelImpl::ENEMIES_WASTED_WAVE ) << std::endl;
        playerText << "Enemies wasted total = " << playerOne->getPlayerModel()->g
      etTraitValue( PlayerModelImpl::ENEMIES_WASTED_TOTAL ) << std::endl;

        if (GameManager::getInstance()->getWindow()->get_ic().get_joystick_count(
      ) > 0)
        {
                CL_InputDevice joystick = GameManager::getInstance()->getWindow()
      ->get_ic().get_joystick();
                playerText << "Joystick name = " << joystick.get_name().c_str() <
      < std::endl;

                for (int i = 0; i < joystick.get_button_count(); i++)
                {
                        if (joystick.get_keycode( i ))
                        {
                                playerText << "Joystick key = " << joystick.get_k
      ey_name( i ).c_str() << std::endl;
                        }
                }

                for (int i = 0; i < joystick.get_axis_count(); i++)
                {
                        playerText << "Joystick axis " << i << " = " << joystick.
      get_axis( i ) << std::endl;
                }
        }

        std::string drawableText = playerText.str();
        float textX = 640.0f - _font->get_text_size(gc, drawableText).width - 10.
      f; 
        float textY = 110.0f;

        _font->draw_text(gc, textX, textY, drawableText, CL_Colorf::red);

        std::ostringstream waveText;
        waveText.precision( 4 );

        waveText << "Wave: " << _waveNumber << std::endl;
        waveText << "Enemies wave: " << _enemiesWave << std::endl;
        waveText << "Enemies wave wasted: " << _enemiesWaveWasted << std::endl;
        waveText << "Enemies total: " << _enemiesTotal << std::endl;
        waveText << "Enemies wasted total: " << _enemiesTotalWasted << std::endl;
      
        waveText << "Shots wave: " << _shotsWave << std::endl;
        waveText << "Shots wave on target: " << _shotsWaveOnTarget << std::endl;
        waveText << "Shots total: " << _shotsTotal << std::endl;
        waveText << "Shots total on target: " << _shotsTotalOnTarget << std::endl
      ;

        std::string waveDrawableText = waveText.str();

        _font->draw_text(gc, 0.0f, 110.0f, waveDrawableText, CL_Colorf::green);

#endif
}
\end{DoxyCode}


Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{d1/d1a/class_test_scene_player_a17140146d2a39f10eb3aed81c067ec24_cgraph}
\end{center}
\end{figure}


\hypertarget{class_test_scene_player_a8285c9f16119d8423a0ed4858327097c}{
\index{TestScenePlayer@{TestScenePlayer}!update@{update}}
\index{update@{update}!TestScenePlayer@{TestScenePlayer}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}void TestScenePlayer::update (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{d1/d1a/class_test_scene_player_a8285c9f16119d8423a0ed4858327097c}


Reimplemented from \hyperlink{class_scene_aa24c7e636c10e4e42650c1374b90bb80}{Scene}.


\begin{DoxyCode}
{
        GameManager* manager = GameManager::getInstance();
        Player* playerOne = manager->getPlayer(0);
        float dt = manager->getDeltaTime();
        PlayerModel* model = playerOne->getPlayerModel();

        if (playerOne->getLives() <= 0)
        {
                GameManager::getInstance()->stopMusic( GameManager::STAGE_1 );
                setNextScene( manager->getGameOverScene() );

                // Last log

                CL_DateTime time = CL_DateTime::get_current_local_time();
                std::ostringstream text;
                text << "Player defeated\n";
                text << time.to_long_time_string().c_str();

                Player* playerOne = GameManager::getInstance()->getPlayer( 0 );
                PlayerModel* model = playerOne->getPlayerModel();

                text << "\nPlayer defeated\n\n ";
                text << "Player: ";
                text << playerOne->getPlayerNumber() + 1;
                text << "\nStats:\n Accuracy ";
                text << model->getTraitValue(PlayerModelImpl::ACCURACY);
                text << "\tLives var ";
                text << model->getTraitValue(PlayerModelImpl::LIVES_VARIATION);
                text << "\tEnemies wave ";
                text << model->getTraitValue(
      PlayerModelImpl::ENEMIES_WASTED_WAVE);
                text << "\tEnemies total ";
                text << model->getTraitValue(
      PlayerModelImpl::ENEMIES_WASTED_TOTAL);
                text << "\nModel name start: ";
                text << model->getName();
                text << "\n";
                text << "==================================\n";

                GameManager::getInstance()->getLogger()->log("Logging end", text.
      str());

                changeToNextScene();
                return;
        }

        // Checks if there is any wave in progress
        if (!_waveOn)
        {
                // If there are any waves to be processed
                if (_waveNumber < _waves.size())
                {
                        waveBegin();
                        createWave(_waveNumber);
                }
                else
                {
                        GameManager::getInstance()->stopMusic( 
      GameManager::STAGE_1 );

                        CL_DateTime time = CL_DateTime::get_current_local_time();
      
                        std::ostringstream text;
                        text << time.to_long_time_string().c_str();

                        Player* playerOne = GameManager::getInstance()->
      getPlayer( 0 );
                        PlayerModel* model = playerOne->getPlayerModel();

                        text << "\nPlayer succeeded\n\n ";
                        text << "Player: ";
                        text << playerOne->getPlayerNumber() + 1;
                        text << "\nStats:\n Accuracy ";
                        text << model->getTraitValue(PlayerModelImpl::ACCURACY);
                        text << "\tLives var ";
                        text << model->getTraitValue(
      PlayerModelImpl::LIVES_VARIATION);
                        text << "\tEnemies wave ";
                        text << model->getTraitValue(
      PlayerModelImpl::ENEMIES_WASTED_WAVE);
                        text << "\tEnemies total ";
                        text << model->getTraitValue(
      PlayerModelImpl::ENEMIES_WASTED_TOTAL);
                        text << "\nModel name start: ";
                        text << model->getName();
                        text << "\n";
                        text << "==================================\n";

                        GameManager::getInstance()->getLogger()->log("Logging end
      ", text.str());

                        changeToNextScene();
                        return;
                }
        }
        else
        {
                if (_enemies.size() == 0)
                {
                        waveFinish();
                }
        }

        // Player updates occur separately because players can drop in or out
        // treating this in entities would be messy
        playerOne->update();

#if _DEBUG

        CL_InputDevice keyboard = manager->getWindow()->get_ic().get_keyboard();

        const float variation = 0.001f;

        if (keyboard.get_keycode(CL_KEY_Y))
        {
                model->setTraitValue(PlayerModelImpl::ACCURACY, model->getTraitVa
      lue(PlayerModelImpl::ACCURACY) + dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_U))
        {
                model->setTraitValue(PlayerModelImpl::LIVES_VARIATION, model->get
      TraitValue(PlayerModelImpl::LIVES_VARIATION) + dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_I))
        {
                model->setTraitValue(PlayerModelImpl::ENEMIES_WASTED_WAVE, model-
      >getTraitValue(PlayerModelImpl::ENEMIES_WASTED_WAVE) + dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_O))
        {
                model->setTraitValue(PlayerModelImpl::ENEMIES_WASTED_TOTAL, model
      ->getTraitValue(PlayerModelImpl::ENEMIES_WASTED_TOTAL) + dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_H))
        {
                model->setTraitValue(PlayerModelImpl::ACCURACY, model->getTraitVa
      lue(PlayerModelImpl::ACCURACY) - dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_J))
        {
                model->setTraitValue(PlayerModelImpl::LIVES_VARIATION, model->get
      TraitValue(PlayerModelImpl::LIVES_VARIATION) - dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_K))
        {
                model->setTraitValue(PlayerModelImpl::ENEMIES_WASTED_WAVE, model-
      >getTraitValue(PlayerModelImpl::ENEMIES_WASTED_WAVE) - dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_L))
        {
                model->setTraitValue(PlayerModelImpl::ENEMIES_WASTED_TOTAL, model
      ->getTraitValue(PlayerModelImpl::ENEMIES_WASTED_TOTAL) - dt*variation);
        }

        if (keyboard.get_keycode(CL_KEY_P))
        {
                model->resetTraits();
        }

        if (keyboard.get_keycode(CL_KEY_E))
        {
                createDebugEnemy();
        }

        if (keyboard.get_keycode(CL_KEY_SPACE))
        {
                std::string modelName = model->getName();

                // Updates player model observed
                AIManager* aimanager = GameManager::getInstance()->getAIManager()
      ;
                aimanager->update();
                
                /*LOGOG_INFO( "Player: %d\nStats:\n Accuracy %f\tLives var %f\tEn
      emies total %f\nModel name before update: %s\nModel name after update: %s\n",
                        playerOne->getPlayerNumber() + 1, playerOne->getPlayerMod
      el()->getTraitValue(PlayerModelImpl::ACCURACY), model->getTraitValue(PlayerModelI
      mpl::LIVES_VARIATION),
                        model->getTraitValue(PlayerModelImpl::ENEMIES_WASTED_TOTA
      L),     modelName.c_str(), playerOne->getPlayerModel()->getName().c_str() );*/
        }

#endif

        // Calls parent implementation of update, updating all Entities
        Scene::update();

        // Treat playerShots and enemyShots collision and out of bounds
        computeShotsCollision();

        // Treat player-enemy collisions
        computePlayerEnemyCollision();

        // Checks if any enemy is dead or out of bounds
        validateEnemies();
}
\end{DoxyCode}


Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{d1/d1a/class_test_scene_player_a8285c9f16119d8423a0ed4858327097c_cgraph}
\end{center}
\end{figure}




The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
\hyperlink{_test_scene_player_8h}{TestScenePlayer.h}\item 
\hyperlink{_test_scene_player_8cpp}{TestScenePlayer.cpp}\end{DoxyCompactItemize}
